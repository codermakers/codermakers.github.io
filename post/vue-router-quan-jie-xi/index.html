
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>Vue-Router 全解析 | CoderMakers</title>
<meta name="description" content="凉风有信，风月无边">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://codermakers.github.io//favicon.ico?v=1587532953221">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://codermakers.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://codermakers.github.io/">
        <img class="avatar" src="https://codermakers.github.io//images/avatar.png?v=1587532953221" alt="" width="32px" height="32px">
      </a>
      <a href="https://codermakers.github.io/">
        <h1 class="site-title">CoderMakers</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">Vue-Router 全解析</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2020-04-08</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://codermakers.github.io/tag/YfntqPZRN/">
                    Vue技术栈修炼
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <p>VueRouter 插件 学习</p>
<h3 id="一-vuerouter-是什么">一、VueRouter 是什么?</h3>
<pre><code class="language-js">VueRouter作为Vue的一插件使用，是一个`url路径跳转的控制器`
</code></pre>
<h3 id="二-基本使用">二、基本使用</h3>
<pre><code class="language-js">//1、安装
npm install vue-router

//2、router/index.js
import Vue from &quot;vue&quot;;
import VueRouter from &quot;vue-router&quot;;
import  routes  from &quot;./routes&quot;;

Vue.use(VueRouter);

//3、实例化路由器并配置
const router = new VueRouter({
 mode: &quot;history&quot;,
 routes
});

export default router;

//4、routes.js
//@导入一级路由组件
import Home from &quot;@/views/Home/Home&quot;;
import About from &quot;@/views/About/About&quot;;
import NotFound from &quot;@/views/NotFound/NotFound&quot;;

export const  = [
 // 配置一级路由
 {
   path: &quot;/&quot;,
   redirect: &quot;/home&quot;
 },
 {
   path: &quot;/home&quot;,
   component: Home 
 },
 {
   path: &quot;/about&quot;,
   component: About 
 },
 {
   path: &quot;*&quot;,
   component: NotFound
 }
];
export default routes;

//5、main.js入口文件
import Vue from &quot;vue&quot;;
import App from &quot;./App.vue&quot;;
import router from &quot;./router&quot;;

Vue.config.productionTip = false;

const MyApp =  new Vue({
 router,
 render: h =&gt; h(App)
}).$mount(&quot;#app&quot;);

//6、APP.vue
&lt;template&gt;
 &lt;div id=&quot;app&quot;&gt;
   &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;
   &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;
   &lt;router-view&gt;&lt;/router-view&gt;
 &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="三-router-link路由导航组件property-introduction">三、router-link路由导航组件(Property Introduction)</h3>
<pre><code class="language-js">//以掘金一级导航为例
&lt;nav&gt;
    &lt;router-link to=&quot;/&quot; active-class=&quot;active&quot; exact&gt;首页&lt;/router-link&gt;
    &lt;router-link to=&quot;/hot&quot; active-class=&quot;active&quot;&gt;热点&lt;/router-link&gt;
    &lt;router-link to=&quot;/topics&quot; active-class=&quot;active&quot;&gt;话题&lt;/router-link&gt;
    &lt;router-link to=&quot;/books&quot; active-class=&quot;active&quot;&gt;小册&lt;/router-link&gt;
    &lt;router-link to=&quot;/activity&quot; active-class=&quot;active&quot;&gt;活动&lt;/router-link&gt;
&lt;/nav&gt;

/*
[说明]
  -1、router-link 组件默认会被渲染成一个a标签,此时点击(激活的)的a,上面有router-link-exact-active router-link-active(利用active-class改写类名).
  -2、tag属性,指定router-link最后渲染成的标签
  -3、exact用于路由切换,完全匹配,激活类名,导航第一个router-link必加
  -4、active-class用于改写激活时的class
*/
</code></pre>
<h3 id="四-路由重定向和别名redirect和alias">四、路由重定向和别名(redirect和alias)</h3>
<pre><code class="language-js">//1.redirect重定向：通常解决不同路由路径(映射的组件相同)带来的迷惑行为,仍以掘金一级导航导航为例,/和/home映射的组件相同,可以使用redirect进行重定向

//用户访问/,url被替换成/home,以下3种写法效果相同，推荐第一种
 1- {  path: &quot;/&quot;,redirect:'/login'} 
 2- {  path: &quot;/&quot;,redirect: { name:'login' } 
 3- {  path: &quot;/&quot;,redirect:to =&gt;{ return '/login' }

 //2.alias 别名:路由的另一个名字,如用户中心/userCenter ,alias为userManager,此时访问/userManager和访问/userCenter,一样，但url仍是userManager
{ path: &quot;/userCenter&quot;, component: User,alias:'userManager' }
</code></pre>
<h3 id="五-命名路由name">五、命名路由(name)</h3>
<pre><code class="language-js">//1、命名路由:通过配置name,标识一个路由,方便路由跳转。
{ path: &quot;/userCenter&quot;,name:'user', component: User }
//2、声明式路由和导航式路由(路由跳转时写法)
router.push({ name: 'user', params: { userId: '123' }})
&lt;router-link :to=&quot;{ name: 'user', params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;
</code></pre>
<h3 id="六-命名视图">六、命名视图</h3>
<pre><code class="language-js">//1、如果想同级显示多个视图(router-view),命名视图就派上用场，比如首页布局:头部(header),侧边栏(siderbar),和主题内容(main)
&lt;div id=&quot;app&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
  &lt;router-view name='siderBar'&gt;&lt;/router-view&gt;
  &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;
&lt;/div&gt;

//2、路由配置
const router = new VueRouter({
  routes: [
    {
      path: '/',
      components: {
        default: Header,
        siderbar,
        Main
      }
    }
  ]
})
</code></pre>
<h3 id="七-动态路由">七、动态路由</h3>
<pre><code class="language-js">//1、有时候需要在同种模式下的路由映射到相同的组件，比如不同id的用户，映射到user组件,这就需要动态路径参数(可以用多个)
{ path: '/user/:id', component: User }  //比如这里的id就是动态路由参数.

//2、多个动态参数,如果想获取动态参数的值，可在$route.params下获取。
{ path: '/user/:username/post/:post_id', component: UserPost }  
//此时访问/user/jack/post/123,$route.params =&gt;{username: &quot;jack&quot;, post_id: &quot;1001&quot;}

//3、值得注意的是:比如/user/foo,切换到/user/bar,Vue会复用组件,路由的生命周期钩子函数不会被调用。如果想响应动态路由参数变化,可用watch做简单监听
const User = {
  template: '&lt;div&gt;userName:{{userName}}&lt;/div&gt;',
  data(){
    return {
      userName:this.$route.params.userName
    }
  }
  watch: {
    '$route' (to, from) {
      this.id = to.params.userName
    }
  }
}
</code></pre>
<h3 id="八-嵌套路由">八、嵌套路由</h3>
<pre><code class="language-js">
// 1、路由是可以进行嵌套的,利用children进行配置,此时就有二级路由、三级路由...
// 2、下面以一个小案例演示:点击`用户列表`进入用户列表,点击每个用户,进入`用户详情组件`,在详情组件点击`用户edit按钮`进入用户编辑组件
// 3、注意：路由映射表的路由写法,动态路由参数前不加/,Vue会自动拼接,但是router-link的to一定要拼接完全,动态拼接时，to前一定要加冒号:
//router.js
const routes = [
  {
    path: &quot;/&quot;,
    name: &quot;Home&quot;,
    component: Home
  },
  {
    path: &quot;/user&quot;,
    component: User,
    children: [
    //这里设置空路由的目的,是避免点击用户列表导航时,router-view没有对应的组件渲染
      { path: &quot;&quot;, component: UserInit },
      { path: &quot;:id&quot;, component: UserDetail },
      { path: &quot;:id/edit&quot;, component: UserEdit }
    ]
  }
];
//App.vue
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;nav&gt;
      &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;
      &lt;router-link to=&quot;/user&quot;&gt;用户列表&lt;/router-link&gt;
    &lt;/nav&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;

//UserInit.vue
&lt;template&gt;
  &lt;div class=&quot;userInit&quot;&gt;
    &lt;h1&gt;用户列表初始界面&lt;/h1&gt;
    &lt;nav&gt;
      &lt;router-link tag=&quot;li&quot; to=&quot;/user/1&quot; exact&gt;
        &lt;a href=&quot;#&quot;&gt;用户1&lt;/a&gt;
      &lt;/router-link&gt;
      &lt;router-link tag=&quot;li&quot; to=&quot;/user/2&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;用户2&lt;/a&gt;
      &lt;/router-link&gt;
      &lt;router-link tag=&quot;li&quot; to=&quot;/user/3&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;用户3&lt;/a&gt;
      &lt;/router-link&gt;
    &lt;/nav&gt;
  &lt;/div&gt;
&lt;/template&gt;
//这里router-link的渲染成li,避免a包裹a的奇怪行为

//UserDetail.vue
&lt;template&gt;
  &lt;div class=&quot;user-detail&quot;&gt;
    &lt;h1&gt;用户详情页面&lt;/h1&gt;
    &lt;p&gt;userId:{{userId}}&lt;/p&gt;
    //这种需要用watch进行监听
    &lt;router-link tag=&quot;button&quot; :to=&quot;'/user/'+userId+'/edit'&quot;&gt;编辑用户&lt;/router-link&gt;
    //拼接路径过长,不需要watch监听
    &lt;router-link tag=&quot;button&quot; :to=&quot;'/user/'+$route.params.id+'/edit'&quot;&gt;编辑用户&lt;/router-link&gt; 
    //命名路由,如果拼接过长，推荐这种
    &lt;router-link tag=&quot;button&quot; :to=&quot;{name:'UserEdit'}&quot;&gt;编辑用户&lt;/router-link&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      userId: this.$route.params.id
    };
  },
  watch: {
    $route(to, from) {
      this.userId = to.params.userId;
    }
  }
};
&lt;/script&gt;

//UserEdit.vue
&lt;template&gt;
  &lt;div class=&quot;user-edit&quot;&gt;
    &lt;h1&gt;用户编辑页面&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="九-路由跳转的两种方式">九、路由跳转的两种方式</h3>
<pre><code class="language-js">//1.声明式导航
&lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;              =&gt;相当于router.push()
&lt;router-link to=&quot;/about&quot; replace&gt;关于&lt;/router-link&gt; =&gt;相当于router.replace()

//2.编程式导航:主要通过router实例上的API方法，如push,go,replace,back,forward等方法实现路由跳转
  - push  =&gt;向history栈中添加一个记录，使得浏览器的`后退按钮`可用
  - go(n) =&gt;在history记录中前进或者后退多少步
  - replace() =&gt;替换掉当前的history记录
  - back() =&gt;同go(-1)
  - forward() =&gt;同go(1)

//Note:编程式路由往往通过点击事件触发
//返回主页
this.$router.push('/') 
返回上一页
this.$router.back()  // this.$router.go(-1)
//下一页
this.$router.forward() //this.$router.go(1) 

</code></pre>
<h3 id="十-路由传参params和query">十、路由传参(params和query)</h3>
<pre><code class="language-js">//1.通过配置meta元信息,meta上可在$route.meta下获取到
const routes = [
  {
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;
  },
  {
    path: &quot;/&quot;,
    component: Home,
    meta: {
      title:'首页',
      requireAuth: false
    }
  },
  {
    path: &quot;/login&quot;,
    component: Login,
    meta: {
      title:'登录页面',
      requireAuth: false
    }
  },
  {
    path: &quot;/classify&quot;,
    component: Classify,
    meta: {
      title:'商品分类',
      requireAuth: false
    }
  },
  {
    path: &quot;/cart&quot;,
    component: Cart,
    meta: {
      title:'购物车',
      requireAuth: true
    }
  },
  {
    path: &quot;/me&quot;,
    component: Me,
    meta: {
      title:'个人中心',
      requireAuth: false
    }
  }
];

//2.通过params进行传参;path和params不能放在一起,否则参数传递不过去，应该使用命名路由,另外to一定要加冒号: 传递的参数可在$route.params获取到,类似于post请求,地址栏url上params不可见
&lt;router-link :to=&quot;{ name:'cart', params:{_time:Date.now()}}&quot;&gt;购物车&lt;/router-link&gt;

//3.通过query进行传参
 //编程式:此时url变为http://localhost:8080/#/cart?locate=zh&amp;q=100,类似于get请求
 this.$router.push({
    name:'cart',
    query:{
      locate:'zh',
      q:100
    }
  })
  
//后记:当然两者可以同时使用,最终都会暴露在$route对象上去
&lt;router-link :to=&quot;{ name:'cart', params:{_time:Date.now()}},query:{locate:'zh',q:100}&quot;&gt;购物车&lt;/router-link&gt;
//相当于
 this.$router.push({
    name:'cart',
    params:{
     _time:Date.now()  
    },
    query:{
      locate:'zh',
      q:100
    }
})
</code></pre>
<h3 id="十一-路由器router和route路由信息对象区别">十一、路由器(router)和$route(路由信息对象)区别</h3>
<pre><code class="language-js">1.router实例:由路由器构造函数实例化的一个路由器实例(Vue实例挂载)
2.$route:当前路由信息对象,里面保存了当前路由的详细信息(路径,传递的参数,元信息..)
</code></pre>
<h3 id="十二-路由模式history和hash">十二、路由模式(history和hash)</h3>
<pre><code class="language-js">//路由模式默认`hash`,如果想选用`history`模式，请通过mode进行配置
 //hash 和history的区别
  -1.hash模式,地址栏url 带`#`,history不带,history比较好看
  -2.history需要后端配置,同时需要后端支持，具体请看`https://router.vuejs.org/zh/guide/essentials/history-mode.html`
  -3.hash模式本质利用window监听hashChange事件,hash的改变,不会重新加载页面,hash能兼容到IE8,并且原来的锚点功能不可用。
    history模式需要后端配置,且只能兼容到IE10,如果后台没有正确的配置,用户访问http://oursite.com/user/id 就会返回404.你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源
    [
     ...
     { path:'*',  component:NotFound }
    ]
</code></pre>
<h3 id="十三-导航守卫">十三、导航守卫</h3>
<pre><code class="language-js">/*
  导航守卫:本质就是在路由跳转过程中的一系列钩子函数。值得注意：路由跳转是一个很大的过程(跳转前,跳转中,跳转后)。我们可以在项目中根据需要合理利用这些钩子函数。按书写位置分:全局守卫、路由独享守卫、组件内部守卫。
 */
//1.全局守卫beforeEach、beforeResolve、afterEach(没有next)、依次按顺序触发,在main.js中书写。
router.beforeEach((to, from, next) =&gt; {
  console.log(&quot;全局前置守卫beforeEach被触发&quot;);
  next();
});
router.beforeResolve((to, from, next) =&gt; {
  console.log(&quot;全局中置守卫beforeResolve被触发&quot;);
  next();
});

router.afterEach((to, from) =&gt; {
  console.log(&quot;全局后置守卫afterEach被触发&quot;);
});
//2.路由独享守卫:路由映射表中书写
const router = new VueRouter({
  routes: [
    {
      path: '/about',
      component: About,
      beforeEnter: (to, from, next) =&gt; {
        console.log(&quot;路由独享守卫beforeEnter被触发&quot;);
         next();
      }
    }
  ]
})
//3.组件内守卫beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave在组件内部书写
export default {
  name: &quot;About&quot;,
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
    console.log(&quot;组件进入beforeRouteEnter被触发&quot;);
    next();
  },
  beforeRouteUpdate(to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
    console.log(&quot;组件被复用时beforeRouteEnter被触发&quot;);
    next();
  },
  beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
    console.log(&quot;组件离开beforeRouteLeave被触发&quot;);
    next();
  }
};
//组件进入守卫beforeRouteEnter由于此时组件还未创建,可通过cb进行组件实例
beforeRouteEnter (to, from, next) {
  next(vm =&gt; {
    // 通过 `vm` 访问组件实例
  })
}
//组件复用守卫beforeRouteUpdate可使用this
beforeRouteUpdate (to, from, next) {
  // just use `this`
  this.name = to.params.name
  next()
}
//组件离开守卫beforeRouteLeave常用于用户还未保存修改前突然离开
beforeRouteLeave (to, from, next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}

//完整的导航解析流程   (从A组件离开,进入B组件,这里排除了keepAlive带来的2个钩子函数)

1、导航被触发。
2、在失活的组件里调用beforeRouteLeave离开守卫。
3、调用全局的 beforeEach 守卫。
4、在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5、在路由配置里调用 beforeEnter。
6、解析异步路由组件。
7、在被激活的组件里调用 beforeRouteEnter。
8、调用全局的 beforeResolve 守卫 (2.5+)。
9、导航被确认。
10、调用全局后置afterEach 钩子
11、触发DOM更新(mounted)
12、用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。

//Notes:to:去往的路由,from:当前要离开的路由,next用来拦截路由,不传表示放行,传入false,表示终止导航,也可传入字符串路径等进行路由跳转,注意一定要写next,不写路由相当于传入false.
</code></pre>
<h3 id="十四-路由元信息meta">十四、路由元信息(meta)</h3>
<pre><code class="language-js">const routes = [
  {
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;
  },
  {
    path: &quot;/home&quot;,
    name: &quot;Home&quot;,
    meta: {
      title: &quot;首页&quot;
    },
    component: () =&gt; import(&quot;@/views/Home.vue&quot;)
  },
  {
    path: &quot;/about&quot;,
    name: &quot;about&quot;,
    meta: {
      title: &quot;关于&quot;
    },
    component: () =&gt; import(&quot;@/views/About.vue&quot;)
  },
  {
    path: &quot;/user&quot;,
    name: &quot;user&quot;,
    meta: {
      title: &quot;用户&quot;
    },
    component: () =&gt; import(&quot;@/views/User.vue&quot;)
  }
];
//当跳转到某个路由时候,$route.meta能获取到这些信息,比如动态改变title
router.beforeEach((to,from,next)=&gt;{
  document.title = to.meta.title;
  next();
})
</code></pre>
<h3 id="十五-过渡动效">十五、过渡动效</h3>
<pre><code class="language-js"> //1.单个路由组件的过渡效果,可用transition包裹路由组件,设置不同的name
//Home.vue
&lt;template&gt;
  &lt;transition name=&quot;slide&quot;&gt;
    &lt;div class=&quot;home&quot;&gt;
      Home
    &lt;/div&gt;
  &lt;/transition&gt;
&lt;/template&gt;

//基本的动态过渡
&lt;transition name=&quot;fade&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/transition&gt;

//2.使用动态的 transition-name：利用watch进行监听$route
&lt;!-- 使用动态的 transition name --&gt;
&lt;transition :name=&quot;transitionName&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/transition&gt;

&lt;script&gt;
//父组件内 watch $route 决定使用哪种过渡
 watch: {
   '$route' (to, from) {
     this.transitionName = &quot;....&quot;
  }
}
&lt;/script&gt;
</code></pre>
<h3 id="十六-滚动行为">十六、滚动行为</h3>
<pre><code class="language-js">//1、scrollBehavior方法作为router实例的配置项存在,可以自定义路由切换时页面如何滚动。并且只能在`history`模式下使用。
//2.始终滚动到顶部
scrollBehavior (to, from, savedPosition) {
  return { x: 0, y: 0 }
}
//3.如果想象原生浏览器表现的那样,切换导航,页面自动滚动到顶部,按下前进或者后退按钮,保存之前网页滚动位置可用savedPosition。
scrollBehavior (to, from, savedPosition) {
  if (savedPosition) {
    return savedPosition
  } else {
    return { x: 0, y: 0 }
  }
}
//4.模拟滚动到锚点
scrollBehavior (to, from, savedPosition) {
  if (to.hash) {
    return {
      selector: to.hash
    }
  }
}

//5.异步滚动:0.5s后滚动到顶部
scrollBehavior (to, from, savedPosition) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve({ x: 0, y: 0 })
    }, 500)
  })
}
</code></pre>
<h3 id="十七-路由懒加载webpack的代码分割和vue的异步组件">十七、路由懒加载(webpack的代码分割和Vue的异步组件)</h3>
<pre><code class="language-js">//路由懒加载:当webpack打包的时候,会将代码打包成一个app.js,如果项目非常大,app.js的体积会非常大,利用webpack的代码分割功能将不同路由对应的组件分割成一个个js代码块,当点击相应的路由,才加载相应的js块
//写法有3种，这里推荐最合适的写法。

//导入一级路由组件
const Home = () =&gt; import(&quot;@/views/Home.vue&quot;);
const Classify = () =&gt; import(&quot;@/views/Classify.vue&quot;);
const Cart = () =&gt; import(&quot;@/views/Cart.vue&quot;);
const Me = () =&gt; import(&quot;@/views/Me.vue&quot;);
const NotFound = () =&gt; import(&quot;@/views/NotFound.vue&quot;);

const routes = [
  { path: &quot;/&quot;,redirect: &quot;/home&quot; },
  { path: &quot;/home&quot;,component: Home },
  { path: &quot;/classify&quot;,omponent: Classify },
  { path: &quot;/cart&quot;, component: Cart },
  { path: &quot;/me&quot;, component: Me },
  { path: &quot;*&quot;,component: NotFound }
];

//或者在配置时直接导入
const routes = [
  {
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;
  },
  {
    path: &quot;/home&quot;,
    name: &quot;Home&quot;,
    component: () =&gt; import(&quot;@/views/Home.vue&quot;)
  },
  {
    path: &quot;/classify&quot;,
    component: () =&gt; import(&quot;@/views/Classify.vue&quot;)
  },
  {
    path: &quot;/cart&quot;,
    component: () =&gt; import(&quot;@/views/Cart.vue&quot;)
  },
  {
    path: &quot;/me&quot;,
    component: () =&gt; import(&quot;@/views/Me.vue&quot;)
  },
  {
    path: &quot;*&quot;,
    component: () =&gt; import(&quot;@/views/NotFound.vue&quot;)
  }
];
</code></pre>
<h3 id="十八-keep-alive-缓存组件httpscnvuejsorgv2apikeep-alive">十八、keep-alive 缓存组件(https://cn.vuejs.org/v2/api/#keep-alive)</h3>
<pre><code class="language-js">//keep-alive本质是Vue的一个内置组件,使被包含的组件保留状态，或避免重新渲染 
//1.缓存普通组件
&lt;keep-alive&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
&lt;keep-alive&gt;
//2.缓存动态组件,比如Home,About、User组件,其中需要Home,User组件缓存(二次切换路由不会触发生命周期钩子函数,F5刷新除外)。
&lt;keep-alive exclude=&quot;About&quot;&gt;
   &lt;router-view&gt;&lt;/router-view&gt;
&lt;keep-alive&gt;
//等价于
&lt;keep-alive include=&quot;Home,User&quot;&gt;
   &lt;router-view&gt;&lt;/router-view&gt;
&lt;keep-alive&gt;

//3.使用正则,数组，必须加冒号:
&lt;keep-alive :include=&quot;['Home', 'User']&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;

//4.路由映射表中配置keepAlive,筛选需要被缓存的组件
const routes = [
  {
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;
  },
  {
    path: &quot;/home&quot;,
    meta: {
      keepAlive: true
    },
    component: () =&gt; import(&quot;@/views/Home.vue&quot;)
  },
  {
    path: &quot;/about&quot;,
    meta: {
      keepAlive: false
    },
    component: () =&gt; import(&quot;@/views/About.vue&quot;)
  },
  {
    path: &quot;/user&quot;,
    meta: {
      keepAlive: true
    },
    component: () =&gt; import(&quot;@/views/User.vue&quot;)
  }
];

//组件
&lt;keep-alive&gt;
    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;


/*
Notes:
    1、keep-alive先匹配组件自身name选项,没有,在匹配components注册的键值
    2、keep-alive 不会在函数式组件中正常工作，因为它们没有缓存实例。
    3、exclude的优先级大于include.
    4、被keepAlive缓存的组件,不会触发生命周期钩子函数，如果想做一些事,可以使用activated(进入缓存组件时触发)钩子函数,而deactivated有点特殊，
    比如home(缓存)组件切换到about(未缓存),home的deactivated钩子会在about的created之后,mounted之前触发。
 */


</code></pre>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://codermakers.github.io/post/js-zhong-this-de-zui-zhong-zhi-xiang-chan-shu/">
              <h3 class="post-title">
                下一篇：JS中This指向最终释义
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">凉风有信，风月无边</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://codermakers.github.io//atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
