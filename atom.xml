<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://codermakers.github.io/</id>
    <title>CoderMakers</title>
    <updated>2020-04-08T07:10:54.136Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://codermakers.github.io/"/>
    <link rel="self" href="https://codermakers.github.io/atom.xml"/>
    <subtitle>凉风有信，风月无边</subtitle>
    <logo>https://codermakers.github.io/images/avatar.png</logo>
    <icon>https://codermakers.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, CoderMakers</rights>
    <entry>
        <title type="html"><![CDATA[Vuex全解析]]></title>
        <id>https://codermakers.github.io/post/vuex-quan-jie-xi/</id>
        <link href="https://codermakers.github.io/post/vuex-quan-jie-xi/">
        </link>
        <updated>2020-04-08T06:54:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-vuex的简明释义">一、Vuex的简明释义</h3>
<pre><code class="language-js">1、Vuex是Vue的一个插件,全局状态管理器
2、Vuex主要解决`多个组件共享状态,组件跨级传参,组件外部管理状态`问题
3、页面刷新，数据丢失，状态不能维持,需要持久化存储方案,可通过本地存储localstorage或者相关的vuex持久化插件vuex-persistedstate,vue-savedata等解决。
4、根据需要选择使用Vuex,使用Vue-detools进行vuex调试。
</code></pre>
<h3 id="二-vuex的核心5个对象">二、Vuex的核心5个对象</h3>
<ul>
<li>2.1 概括</li>
</ul>
<pre><code class="language-js">1、state  -&gt;状态,相当于中央仓库中的数据。
2、getters -&gt;相当于state的计算属性，依赖于state. 
3、mutation -&gt;相当于直接修改state的method方法,里面不允许异步操作，如果需要需要异步操作，直接利用action去触发mutation，更改state。
4、action -&gt;相当于mutation的附加函数，允许异步操作，然后提交mutation 
5、module-&gt;当项目应用vuex进行状态管理,随着项目越大,store中配置项，state、getters等会变得很大，不易管理，可用module对象进行分模块管理。各个模块维护自己的state,getters等配置项。
</code></pre>
<ul>
<li>2.2 state 详述</li>
</ul>
<pre><code class="language-js">[摘要]：
1、自store实例注册在根实例中,其中state,getters的数据在任意组件可通过this.$store.state.XX或者this.$store.getters.XXX获取。
2、为了编码整洁，一般在组件内部利用computed进行局部映射,再利用{{}}在template进行书写。
3、利用mapState和mapGetters辅助函数简化写法。
-------------------------------------------------------------------------
1)、基本使用
&lt;template&gt;
  &lt;div&gt;{{count}}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    computed: {
      count() {
        return this.$store.state.count;
      }
    }
  };
&lt;/script&gt;

2）通过mapState辅助函数简化代码 -1 传入对象
&lt;script&gt;
  import { mapState } from &quot;vuex&quot;;
  export default {
    computed: mapState({
      count: state =&gt; state.count //导致组件本地计算属性不可用
    })
  };
&lt;/script&gt;
-2 计算属性和state同名,可传入['字符串']进行映射
&lt;script&gt;
  import { mapState } from &quot;vuex&quot;;
  export default {
    computed: mapState([&quot;count&quot;]) //组件本地计算属性仍不可用
  };
&lt;/script&gt;

-3 使用...解决本地计算属性和映射的计算属性共存
&lt;script&gt;
  import { mapState } from &quot;vuex&quot;;
  export default {
    localComputed() {
      /*本地计算属性*/
    },
    ...mapState([&quot;count&quot;])
  };
&lt;/script&gt;
</code></pre>
<ul>
<li>2.3 getters 详述(计算属性:缓存特性)</li>
</ul>
<pre><code class="language-js">1)基本使用
当store注入APP组件,其中组件可根据`this.$store.getters.xxxx`获取对应的getters，
组件中通常通过`计算属性`进行返回，最终{{}},反映在在template模板中。 - index.js

&lt;script&gt;
  const store = new Vuex.Store({
    state: {
      count: 0
    },
    getters: {
      doubleCount: state =&gt; state * 2
    }
  });
&lt;/script&gt;

-ComA.vue组件

&lt;template&gt;
  &lt;div&gt;{{doubleCount}}&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import { mapState } from &quot;vuex&quot;;
  export default {
    computed: {
      doubleCount() {
        return this.$store.getters.doubleCount;
      }
    }
  };
&lt;/script&gt;

2)getters默认接受state,和其他getters参数,也可返回函数,调用时,不缓存结果.

&lt;script&gt;
  const store = new Vuex.Store({
    state: {
      todos: [
        { id: 1, text: &quot;...&quot;, done: true },
        { id: 2, text: &quot;...&quot;, done: false }
      ]
    },
    getters: {
      doneTodos: state =&gt; state.todos.filter(todo =&gt; todo.done), //筛选完成的todos
      doneTodosCount: (state, getters) =&gt; getters.doneTodos.length, //筛选完成的todo的条目数
      getTodoById: state =&gt; id =&gt; state.todos.find(todo =&gt; todo.id === id) //查询时有用,每次store.gtters.getTodoById(2) 方法调用,不会缓存结果
    }
  });
&lt;/script&gt;

2)通过mapGetters辅助函数,简化代码,映射
&lt;script&gt;
  import { mapGetters } from &quot;vuex&quot;;

  export default {
    // ...
    computed: {
      // 使用对象展开运算符将 getter 混入 computed 对象中
      ...mapGetters([
        &quot;doneTodos&quot;
        &quot;doneTodosCount&quot;,
        // ...
      ])
    }
  };
&lt;/script&gt;
</code></pre>
<ul>
<li>2.4 mutations(变更 state 的唯一方法)-&gt;[commit 触发]</li>
</ul>
<pre><code class="language-js">1)基本使用:直接commit触发
&lt;script&gt;
  const store = new Vuex.Store({
    state: {
      count: 0;
    },
    mutations: {
      increase(state, n) {
        // 变更状态
        state.count += n;
      }
    },
    actions: {
      increaseAction({ commit }, n) {
        commit(&quot;increase&quot;, n);
      }
    }
  });
&lt;/script&gt;
- commit触发
&lt;template&gt;
  &lt;button @click=&quot;addCount(5)&quot;&gt;&lt;/button&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    methods: {
      addCount(n) {
        this.$store.commit(&quot;increase&quot;, n);
      }
    }
  };
&lt;/script&gt;

2)通过mapMutations辅助函数简化代码
&lt;script&gt;
  import { mapMutations } from &quot;vuex&quot;;
  export default {
    // ...
    methods: {
      // 传数组,方法名和mutation同名,推荐这个
      ...mapMutations([
        &quot;increase&quot; // 将 `this.increase()` 映射为 `this.$store.commit('increase')`
      ]),
      // 传对象,方法名和mutation不同名,推荐传对象。
      ...mapMutations({
        addCount: &quot;increase&quot; // 将 `this.addCount()` 映射为 `this.$store.commit('increment')`
      })
    }
  };
&lt;/script&gt;
3)通过触发action，间接提交mutation(dispatch),稍后细讲。
&lt;script&gt;
  export default {
    methods: {
      addCount(n) {
        this.$store.dispatch(&quot;increaseAction&quot;, n);
      }
    }
  };
&lt;/script&gt;
4)Vuex 中的mutation同event类似,每次提交Mutation实际是{type:'eventName',payload:'载荷'}的传递。

//项目实际上传递payload不会是计数器这么简单,一个字符串或者一个数字,往往是一个对象。
// store.js
export default new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increase(state, n) {
      state.count += n;
    }
  },
  actions: {
    increaseAction({ commit }, payload) {
      setTimeout(() =&gt; {
        commit(&quot;increase&quot;, payload.amount);
      }, payload.duration);
    }
  }
});

//Home.vue 按钮button触发
&lt;button @click=&quot;addCount({ amount:10,duration:1000})&quot;&gt;加10&lt;/button&gt;

&lt;script&gt;
import { mapActions } from &quot;vuex&quot;;
export default {
  name: &quot;Home&quot;,
  data() {
    return {};
  },
  computed: {
    count() {
      return this.$store.state.count;
    }
  },
  methods: {
    ...mapActions({
      addCount: &quot;increaseAction&quot;
    })
  }
};
&lt;/script&gt;
5)提交mutation的风格:载荷形式提交,对象形式提交
&lt;button @click=&quot;addCount&quot;&gt;加10&lt;/button&gt;

//5.1载荷形式提交
 this.$store.commit(&quot;increase&quot;, { by: 10 });
 
//5.2 对象形式提交:Payload ==&gt; {type: &quot;increase&quot;, by: 10}
 this.$store.commit({
    type: &quot;increase&quot;,
    by: 10
 });

//store.js
 mutations: {
   increase(state, payload) {
    state.count += payload.by;
  }
}
&lt;/script&gt;
</code></pre>
<ul>
<li>2.5 Action(行为)-&gt;主要用来异步获取数据，再提交 mutation</li>
</ul>
<pre><code class="language-js">/*
 1、action提交的是mutation,不是直接变state,
 2、Action 可以包含任意异步操作。
 3、Action中可以使用promise与async await
*/
//store.js
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context){
      console.log(context);
      context.commit('increment')
    }
  }
})
//Home.vue 按钮button触发,控制台打印this.$store对比store实例和context对象

//store实例
let store = {
  commit:() =&gt;{},
  dispatch:()=&gt;{},
  getters:{},
  state:{},
  ....
}
//context对象
var context = {
  commit:() =&gt;{},
  dispatch:()=&gt;{},
  getters: {}
  rootGetters: {}
  rootState: {}
  state: {}  
}

//1、由上可知,context和store两者并非完全相同,根据对象解构，在module模块中,将state,rootState,commit...结构出来,书写以及对该模块的管理将非常有

//2、action支持promise和async 和await
 //返回promise
actions: {
  actionA ({ commit }) {
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        commit('someMutation')
        resolve()
      }, 1000)
    })
  }
}

//async 和await组合action,假设 getData() 和 getOtherData() 返回的是 Promise

actions: {
  async actionA ({ commit }) {
    commit('gotData', await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch('actionA') // 等待 actionA 完成
    commit('gotOtherData', await getOtherData())
  }
}
- 2.6 modules(模块管理)
```js
/*
 1、如果项目足够大,Vuex实例化的store实例会变得很大,所以modules的出现就是为了解决这个问题。
 2、每个模块中都有自己的state,getters,mutation,action。
 3、在这几个对象中模块内部的 action、mutation 和 getter 是注册在全局命名空间,而state是模块自己私有的。下面以例子说明
*/
//modules/moduleA.js
export default {
  state: {
    value: 1
  },
  getters: {
    doubleValue: state =&gt; state.value * 2
  },
  mutations: {
    increaseA(state, getters, rootState) {
      state.value++;
    }
  },
  actions: {
    actionIncreaseA({ state, commit, rootState }) {
      commit(&quot;increaseA&quot;);
    }
  }
};

//store/index.js
import Vue from &quot;vue&quot;;
import Vuex from &quot;vuex&quot;;
import moduleA from &quot;./module/moduleA&quot;;

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    count: 1
  },
  getters: {
    doubleCount(state) {
      return state.count * 2;
    }
  },
  mutations: {
    increase(state) {
      state.count++;
    }
  },
  modules: {
    a: moduleA
  }
});

//Home.vue
&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    &lt;button @click=&quot;addOne&quot;&gt;触发moduleA中的action&lt;/button&gt;
    &lt;h1&gt;moduleA中的state:{{value}}&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import { mapGetters } from &quot;vuex&quot;;
export default {
  name: &quot;Home&quot;,
  data() {
    return {};
  },
  computed: {
    value() {
      return this.$store.state.a.value;
    }
  },
  methods: {
    addOne() {
      this.$store.dispatch(&quot;actionIncreaseA&quot;);
    }
  }
};
&lt;/script&gt;
/*
 4.以上面的例子可知，证明了3的正确,state是模块私有，getters和mutations,以actions是在全局命名空间的问题，所以在多模块的情况下，不可避免mutation会重名,Vuex官方给出了2种解决方案。
 */
 4.1使用常量代替mutation事件类型：改写
    /*
      Mutation-types.js
    */
    //getters
    export const DOUBLE_VALUE = &quot;moduleA/doubleValue&quot;
    export const DOUBLE_COUNT = &quot;index/doubleCount&quot;
    
    //mutations
    export const MUTA_INCREASE_VALUE = &quot;moduleA/muta_increase_value&quot;
    export const MUTA_INCREASE_COUNT = &quot;index/muta_increase_count&quot;
    
    //actions 
    export const VALUE_INCREASE_ACTION = &quot;moduleA/value_increase_action&quot;
    export const COUNT_INCREASE_ACTION = &quot;index/count_increase_action&quot;
   
   /*
    moduleA.js
   */
    import * as types from &quot;../mutation-types&quot;;
    export default {
      state: {
        value: 1
      },
      getters: {
        [types.DOUBLE_VALUE]: state =&gt; state.value * 2
      },
      mutations: {
        [types.MUTA_INCREASE_VALUE](state, getters, rootState) {
          state.value++;
        }
      },
      actions: {
        [types.VALUE_INCREASE_ACTION]({ state, commit, rootState }) {
          commit(types.MUTA_INCREASE_VALUE);
        }
      }
    };
    /*
     index.js
    */
    import Vue from &quot;vue&quot;;
    import Vuex from &quot;vuex&quot;;
    import moduleA from &quot;./module/moduleA&quot;;
    import * as types from &quot;./mutation-types&quot;;
    
    Vue.use(Vuex);
    
    export default new Vuex.Store({
      state: {
        count: 1
      },
      getters: {
        [types.DOUBLE_COUNT](state) {
          return state.count * 2;
        }
      },
      mutations: {
        [types.MUTA_INCREASE_COUNT](state) {
          state.count++;
        }
      },
      modules: {
        a: moduleA
      }
    }); 
    /*
      Home.vue
     */
 
    &lt;template&gt;
      &lt;div class=&quot;home&quot;&gt;
        &lt;button @click=&quot;addOne&quot;&gt;触发moduleA中的action&lt;/button&gt;
        &lt;h1&gt;moduleA中的state:{{value}}&lt;/h1&gt;
      &lt;/div&gt;
    &lt;/template&gt;

  &lt;script&gt;
    import * as types from &quot;../store/mutation-types&quot;;
    import { mapGetters } from &quot;vuex&quot;;
    export default {
      name: &quot;Home&quot;,
      data() {
        return {};
      },
      computed: {
        value() {
          return this.$store.state.a.value;
        }
      },
      methods: {
        addOne() {
          this.$store.dispatch(types.VALUE_INCREASE_ACTION);
        }
      }
    };
    &lt;/script&gt;
4.2 使用Vuex提供的方案,为模块配置namespaced属性。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名.
const store = new Vuex.Store({
  modules: {
    account: {
      namespaced: true,

      // 模块内容（module assets）
      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响
      getters: {
        isAdmin () { ... } // -&gt; getters['account/isAdmin']
      },
      actions: {
        login () { ... } // -&gt; dispatch('account/login')
      },
      mutations: {
        login () { ... } // -&gt; commit('account/login')
      },

      // 嵌套模块
      modules: {
        // 继承父模块的命名空间
        myPage: {
          state: { ... },
          getters: {
            profile () { ... } // -&gt; getters['account/profile']
          }
        },

        // 进一步嵌套命名空间
        posts: {
          namespaced: true,

          state: { ... },
          getters: {
            popular () { ... } // -&gt; getters['account/posts/popular']
          }
        }
      }
    }
  }
})
/*
 如果想具体了解vuex提供的命名空间问题,请参考https://vuex.vuejs.org/zh/guide/modules.html
*/
</code></pre>
<h3 id="三-官方推荐的的目录结构">三、官方推荐的的目录结构</h3>
<pre><code class="language-js">/*
  1、应用层级的状态应该集中到单个 store 对象中。
  2、提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。
  3、异步逻辑都应该封装到 action 里面。
  4、如果store实例过大,推荐将getters,mutations,actions进行分割。
*/
├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue-Router 全解析]]></title>
        <id>https://codermakers.github.io/post/vue-router-quan-jie-xi/</id>
        <link href="https://codermakers.github.io/post/vue-router-quan-jie-xi/">
        </link>
        <updated>2020-04-08T05:08:45.000Z</updated>
        <content type="html"><![CDATA[<p>VueRouter 插件 学习</p>
<h3 id="一-vuerouter-是什么">一、VueRouter 是什么?</h3>
<pre><code class="language-js">VueRouter作为Vue的一插件使用，是一个`url路径跳转的控制器`
</code></pre>
<h3 id="二-基本使用">二、基本使用</h3>
<pre><code class="language-js">//1、安装
npm install vue-router

//2、router/index.js
import Vue from &quot;vue&quot;;
import VueRouter from &quot;vue-router&quot;;
import  routes  from &quot;./routes&quot;;

Vue.use(VueRouter);

//3、实例化路由器并配置
const router = new VueRouter({
 mode: &quot;history&quot;,
 routes
});

export default router;

//4、routes.js
//@导入一级路由组件
import Home from &quot;@/views/Home/Home&quot;;
import About from &quot;@/views/About/About&quot;;
import NotFound from &quot;@/views/NotFound/NotFound&quot;;

export const  = [
 // 配置一级路由
 {
   path: &quot;/&quot;,
   redirect: &quot;/home&quot;
 },
 {
   path: &quot;/home&quot;,
   component: Home 
 },
 {
   path: &quot;/about&quot;,
   component: About 
 },
 {
   path: &quot;*&quot;,
   component: NotFound
 }
];
export default routes;

//5、main.js入口文件
import Vue from &quot;vue&quot;;
import App from &quot;./App.vue&quot;;
import router from &quot;./router&quot;;

Vue.config.productionTip = false;

const MyApp =  new Vue({
 router,
 render: h =&gt; h(App)
}).$mount(&quot;#app&quot;);

//6、APP.vue
&lt;template&gt;
 &lt;div id=&quot;app&quot;&gt;
   &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;
   &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt;
   &lt;router-view&gt;&lt;/router-view&gt;
 &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="三-router-link路由导航组件property-introduction">三、router-link路由导航组件(Property Introduction)</h3>
<pre><code class="language-js">//以掘金一级导航为例
&lt;nav&gt;
    &lt;router-link to=&quot;/&quot; active-class=&quot;active&quot; exact&gt;首页&lt;/router-link&gt;
    &lt;router-link to=&quot;/hot&quot; active-class=&quot;active&quot;&gt;热点&lt;/router-link&gt;
    &lt;router-link to=&quot;/topics&quot; active-class=&quot;active&quot;&gt;话题&lt;/router-link&gt;
    &lt;router-link to=&quot;/books&quot; active-class=&quot;active&quot;&gt;小册&lt;/router-link&gt;
    &lt;router-link to=&quot;/activity&quot; active-class=&quot;active&quot;&gt;活动&lt;/router-link&gt;
&lt;/nav&gt;

/*
[说明]
  -1、router-link 组件默认会被渲染成一个a标签,此时点击(激活的)的a,上面有router-link-exact-active router-link-active(利用active-class改写类名).
  -2、tag属性,指定router-link最后渲染成的标签
  -3、exact用于路由切换,完全匹配,激活类名,导航第一个router-link必加
  -4、active-class用于改写激活时的class
*/
</code></pre>
<h3 id="四-路由重定向和别名redirect和alias">四、路由重定向和别名(redirect和alias)</h3>
<pre><code class="language-js">//1.redirect重定向：通常解决不同路由路径(映射的组件相同)带来的迷惑行为,仍以掘金一级导航导航为例,/和/home映射的组件相同,可以使用redirect进行重定向

//用户访问/,url被替换成/home,以下3种写法效果相同，推荐第一种
 1- {  path: &quot;/&quot;,redirect:'/login'} 
 2- {  path: &quot;/&quot;,redirect: { name:'login' } 
 3- {  path: &quot;/&quot;,redirect:to =&gt;{ return '/login' }

 //2.alias 别名:路由的另一个名字,如用户中心/userCenter ,alias为userManager,此时访问/userManager和访问/userCenter,一样，但url仍是userManager
{ path: &quot;/userCenter&quot;, component: User,alias:'userManager' }
</code></pre>
<h3 id="五-命名路由name">五、命名路由(name)</h3>
<pre><code class="language-js">//1、命名路由:通过配置name,标识一个路由,方便路由跳转。
{ path: &quot;/userCenter&quot;,name:'user', component: User }
//2、声明式路由和导航式路由(路由跳转时写法)
router.push({ name: 'user', params: { userId: '123' }})
&lt;router-link :to=&quot;{ name: 'user', params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;
</code></pre>
<h3 id="六-命名视图">六、命名视图</h3>
<pre><code class="language-js">//1、如果想同级显示多个视图(router-view),命名视图就派上用场，比如首页布局:头部(header),侧边栏(siderbar),和主题内容(main)
&lt;div id=&quot;app&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
  &lt;router-view name='siderBar'&gt;&lt;/router-view&gt;
  &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;
&lt;/div&gt;

//2、路由配置
const router = new VueRouter({
  routes: [
    {
      path: '/',
      components: {
        default: Header,
        siderbar,
        Main
      }
    }
  ]
})
</code></pre>
<h3 id="七-动态路由">七、动态路由</h3>
<pre><code class="language-js">//1、有时候需要在同种模式下的路由映射到相同的组件，比如不同id的用户，映射到user组件,这就需要动态路径参数(可以用多个)
{ path: '/user/:id', component: User }  //比如这里的id就是动态路由参数.

//2、多个动态参数,如果想获取动态参数的值，可在$route.params下获取。
{ path: '/user/:username/post/:post_id', component: UserPost }  
//此时访问/user/jack/post/123,$route.params =&gt;{username: &quot;jack&quot;, post_id: &quot;1001&quot;}

//3、值得注意的是:比如/user/foo,切换到/user/bar,Vue会复用组件,路由的生命周期钩子函数不会被调用。如果想响应动态路由参数变化,可用watch做简单监听
const User = {
  template: '&lt;div&gt;userName:{{userName}}&lt;/div&gt;',
  data(){
    return {
      userName:this.$route.params.userName
    }
  }
  watch: {
    '$route' (to, from) {
      this.id = to.params.userName
    }
  }
}
</code></pre>
<h3 id="八-嵌套路由">八、嵌套路由</h3>
<pre><code class="language-js">
// 1、路由是可以进行嵌套的,利用children进行配置,此时就有二级路由、三级路由...
// 2、下面以一个小案例演示:点击`用户列表`进入用户列表,点击每个用户,进入`用户详情组件`,在详情组件点击`用户edit按钮`进入用户编辑组件
// 3、注意：路由映射表的路由写法,动态路由参数前不加/,Vue会自动拼接,但是router-link的to一定要拼接完全,动态拼接时，to前一定要加冒号:
//router.js
const routes = [
  {
    path: &quot;/&quot;,
    name: &quot;Home&quot;,
    component: Home
  },
  {
    path: &quot;/user&quot;,
    component: User,
    children: [
    //这里设置空路由的目的,是避免点击用户列表导航时,router-view没有对应的组件渲染
      { path: &quot;&quot;, component: UserInit },
      { path: &quot;:id&quot;, component: UserDetail },
      { path: &quot;:id/edit&quot;, component: UserEdit }
    ]
  }
];
//App.vue
&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;nav&gt;
      &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;
      &lt;router-link to=&quot;/user&quot;&gt;用户列表&lt;/router-link&gt;
    &lt;/nav&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;

//UserInit.vue
&lt;template&gt;
  &lt;div class=&quot;userInit&quot;&gt;
    &lt;h1&gt;用户列表初始界面&lt;/h1&gt;
    &lt;nav&gt;
      &lt;router-link tag=&quot;li&quot; to=&quot;/user/1&quot; exact&gt;
        &lt;a href=&quot;#&quot;&gt;用户1&lt;/a&gt;
      &lt;/router-link&gt;
      &lt;router-link tag=&quot;li&quot; to=&quot;/user/2&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;用户2&lt;/a&gt;
      &lt;/router-link&gt;
      &lt;router-link tag=&quot;li&quot; to=&quot;/user/3&quot;&gt;
        &lt;a href=&quot;#&quot;&gt;用户3&lt;/a&gt;
      &lt;/router-link&gt;
    &lt;/nav&gt;
  &lt;/div&gt;
&lt;/template&gt;
//这里router-link的渲染成li,避免a包裹a的奇怪行为

//UserDetail.vue
&lt;template&gt;
  &lt;div class=&quot;user-detail&quot;&gt;
    &lt;h1&gt;用户详情页面&lt;/h1&gt;
    &lt;p&gt;userId:{{userId}}&lt;/p&gt;
    //这种需要用watch进行监听
    &lt;router-link tag=&quot;button&quot; :to=&quot;'/user/'+userId+'/edit'&quot;&gt;编辑用户&lt;/router-link&gt;
    //拼接路径过长,不需要watch监听
    &lt;router-link tag=&quot;button&quot; :to=&quot;'/user/'+$route.params.id+'/edit'&quot;&gt;编辑用户&lt;/router-link&gt; 
    //命名路由,如果拼接过长，推荐这种
    &lt;router-link tag=&quot;button&quot; :to=&quot;{name:'UserEdit'}&quot;&gt;编辑用户&lt;/router-link&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      userId: this.$route.params.id
    };
  },
  watch: {
    $route(to, from) {
      this.userId = to.params.userId;
    }
  }
};
&lt;/script&gt;

//UserEdit.vue
&lt;template&gt;
  &lt;div class=&quot;user-edit&quot;&gt;
    &lt;h1&gt;用户编辑页面&lt;/h1&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h3 id="九-路由跳转的两种方式">九、路由跳转的两种方式</h3>
<pre><code class="language-js">//1.声明式导航
&lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;              =&gt;相当于router.push()
&lt;router-link to=&quot;/about&quot; replace&gt;关于&lt;/router-link&gt; =&gt;相当于router.replace()

//2.编程式导航:主要通过router实例上的API方法，如push,go,replace,back,forward等方法实现路由跳转
  - push  =&gt;向history栈中添加一个记录，使得浏览器的`后退按钮`可用
  - go(n) =&gt;在history记录中前进或者后退多少步
  - replace() =&gt;替换掉当前的history记录
  - back() =&gt;同go(-1)
  - forward() =&gt;同go(1)

//Note:编程式路由往往通过点击事件触发
//返回主页
this.$router.push('/') 
返回上一页
this.$router.back()  // this.$router.go(-1)
//下一页
this.$router.forward() //this.$router.go(1) 

</code></pre>
<h3 id="十-路由传参params和query">十、路由传参(params和query)</h3>
<pre><code class="language-js">//1.通过配置meta元信息,meta上可在$route.meta下获取到
const routes = [
  {
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;
  },
  {
    path: &quot;/&quot;,
    component: Home,
    meta: {
      title:'首页',
      requireAuth: false
    }
  },
  {
    path: &quot;/login&quot;,
    component: Login,
    meta: {
      title:'登录页面',
      requireAuth: false
    }
  },
  {
    path: &quot;/classify&quot;,
    component: Classify,
    meta: {
      title:'商品分类',
      requireAuth: false
    }
  },
  {
    path: &quot;/cart&quot;,
    component: Cart,
    meta: {
      title:'购物车',
      requireAuth: true
    }
  },
  {
    path: &quot;/me&quot;,
    component: Me,
    meta: {
      title:'个人中心',
      requireAuth: false
    }
  }
];

//2.通过params进行传参;path和params不能放在一起,否则参数传递不过去，应该使用命名路由,另外to一定要加冒号: 传递的参数可在$route.params获取到,类似于post请求,地址栏url上params不可见
&lt;router-link :to=&quot;{ name:'cart', params:{_time:Date.now()}}&quot;&gt;购物车&lt;/router-link&gt;

//3.通过query进行传参
 //编程式:此时url变为http://localhost:8080/#/cart?locate=zh&amp;q=100,类似于get请求
 this.$router.push({
    name:'cart',
    query:{
      locate:'zh',
      q:100
    }
  })
  
//后记:当然两者可以同时使用,最终都会暴露在$route对象上去
&lt;router-link :to=&quot;{ name:'cart', params:{_time:Date.now()}},query:{locate:'zh',q:100}&quot;&gt;购物车&lt;/router-link&gt;
//相当于
 this.$router.push({
    name:'cart',
    params:{
     _time:Date.now()  
    },
    query:{
      locate:'zh',
      q:100
    }
})
</code></pre>
<h3 id="十一-路由器router和route路由信息对象区别">十一、路由器(router)和$route(路由信息对象)区别</h3>
<pre><code class="language-js">1.router实例:由路由器构造函数实例化的一个路由器实例(Vue实例挂载)
2.$route:当前路由信息对象,里面保存了当前路由的详细信息(路径,传递的参数,元信息..)
</code></pre>
<h3 id="十二-路由模式history和hash">十二、路由模式(history和hash)</h3>
<pre><code class="language-js">//路由模式默认`hash`,如果想选用`history`模式，请通过mode进行配置
 //hash 和history的区别
  -1.hash模式,地址栏url 带`#`,history不带,history比较好看
  -2.history需要后端配置,同时需要后端支持，具体请看`https://router.vuejs.org/zh/guide/essentials/history-mode.html`
  -3.hash模式本质利用window监听hashChange事件,hash的改变,不会重新加载页面,hash能兼容到IE8,并且原来的锚点功能不可用。
    history模式需要后端配置,且只能兼容到IE10,如果后台没有正确的配置,用户访问http://oursite.com/user/id 就会返回404.你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源
    [
     ...
     { path:'*',  component:NotFound }
    ]
</code></pre>
<h3 id="十三-导航守卫">十三、导航守卫</h3>
<pre><code class="language-js">/*
  导航守卫:本质就是在路由跳转过程中的一系列钩子函数。值得注意：路由跳转是一个很大的过程(跳转前,跳转中,跳转后)。我们可以在项目中根据需要合理利用这些钩子函数。按书写位置分:全局守卫、路由独享守卫、组件内部守卫。
 */
//1.全局守卫beforeEach、beforeResolve、afterEach(没有next)、依次按顺序触发,在main.js中书写。
router.beforeEach((to, from, next) =&gt; {
  console.log(&quot;全局前置守卫beforeEach被触发&quot;);
  next();
});
router.beforeResolve((to, from, next) =&gt; {
  console.log(&quot;全局中置守卫beforeResolve被触发&quot;);
  next();
});

router.afterEach((to, from) =&gt; {
  console.log(&quot;全局后置守卫afterEach被触发&quot;);
});
//2.路由独享守卫:路由映射表中书写
const router = new VueRouter({
  routes: [
    {
      path: '/about',
      component: About,
      beforeEnter: (to, from, next) =&gt; {
        console.log(&quot;路由独享守卫beforeEnter被触发&quot;);
         next();
      }
    }
  ]
})
//3.组件内守卫beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave在组件内部书写
export default {
  name: &quot;About&quot;,
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
    console.log(&quot;组件进入beforeRouteEnter被触发&quot;);
    next();
  },
  beforeRouteUpdate(to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
    console.log(&quot;组件被复用时beforeRouteEnter被触发&quot;);
    next();
  },
  beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
    console.log(&quot;组件离开beforeRouteLeave被触发&quot;);
    next();
  }
};
//组件进入守卫beforeRouteEnter由于此时组件还未创建,可通过cb进行组件实例
beforeRouteEnter (to, from, next) {
  next(vm =&gt; {
    // 通过 `vm` 访问组件实例
  })
}
//组件复用守卫beforeRouteUpdate可使用this
beforeRouteUpdate (to, from, next) {
  // just use `this`
  this.name = to.params.name
  next()
}
//组件离开守卫beforeRouteLeave常用于用户还未保存修改前突然离开
beforeRouteLeave (to, from, next) {
  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
  if (answer) {
    next()
  } else {
    next(false)
  }
}

//完整的导航解析流程   (从A组件离开,进入B组件,这里排除了keepAlive带来的2个钩子函数)

1、导航被触发。
2、在失活的组件里调用beforeRouteLeave离开守卫。
3、调用全局的 beforeEach 守卫。
4、在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5、在路由配置里调用 beforeEnter。
6、解析异步路由组件。
7、在被激活的组件里调用 beforeRouteEnter。
8、调用全局的 beforeResolve 守卫 (2.5+)。
9、导航被确认。
10、调用全局后置afterEach 钩子
11、触发DOM更新(mounted)
12、用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。

//Notes:to:去往的路由,from:当前要离开的路由,next用来拦截路由,不传表示放行,传入false,表示终止导航,也可传入字符串路径等进行路由跳转,注意一定要写next,不写路由相当于传入false.
</code></pre>
<h3 id="十四-路由元信息meta">十四、路由元信息(meta)</h3>
<pre><code class="language-js">const routes = [
  {
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;
  },
  {
    path: &quot;/home&quot;,
    name: &quot;Home&quot;,
    meta: {
      title: &quot;首页&quot;
    },
    component: () =&gt; import(&quot;@/views/Home.vue&quot;)
  },
  {
    path: &quot;/about&quot;,
    name: &quot;about&quot;,
    meta: {
      title: &quot;关于&quot;
    },
    component: () =&gt; import(&quot;@/views/About.vue&quot;)
  },
  {
    path: &quot;/user&quot;,
    name: &quot;user&quot;,
    meta: {
      title: &quot;用户&quot;
    },
    component: () =&gt; import(&quot;@/views/User.vue&quot;)
  }
];
//当跳转到某个路由时候,$route.meta能获取到这些信息,比如动态改变title
router.beforeEach((to,from,next)=&gt;{
  document.title = to.meta.title;
  next();
})
</code></pre>
<h3 id="十五-过渡动效">十五、过渡动效</h3>
<pre><code class="language-js"> //1.单个路由组件的过渡效果,可用transition包裹路由组件,设置不同的name
//Home.vue
&lt;template&gt;
  &lt;transition name=&quot;slide&quot;&gt;
    &lt;div class=&quot;home&quot;&gt;
      Home
    &lt;/div&gt;
  &lt;/transition&gt;
&lt;/template&gt;

//基本的动态过渡
&lt;transition name=&quot;fade&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/transition&gt;

//2.使用动态的 transition-name：利用watch进行监听$route
&lt;!-- 使用动态的 transition name --&gt;
&lt;transition :name=&quot;transitionName&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/transition&gt;

&lt;script&gt;
//父组件内 watch $route 决定使用哪种过渡
 watch: {
   '$route' (to, from) {
     this.transitionName = &quot;....&quot;
  }
}
&lt;/script&gt;
</code></pre>
<h3 id="十六-滚动行为">十六、滚动行为</h3>
<pre><code class="language-js">//1、scrollBehavior方法作为router实例的配置项存在,可以自定义路由切换时页面如何滚动。并且只能在`history`模式下使用。
//2.始终滚动到顶部
scrollBehavior (to, from, savedPosition) {
  return { x: 0, y: 0 }
}
//3.如果想象原生浏览器表现的那样,切换导航,页面自动滚动到顶部,按下前进或者后退按钮,保存之前网页滚动位置可用savedPosition。
scrollBehavior (to, from, savedPosition) {
  if (savedPosition) {
    return savedPosition
  } else {
    return { x: 0, y: 0 }
  }
}
//4.模拟滚动到锚点
scrollBehavior (to, from, savedPosition) {
  if (to.hash) {
    return {
      selector: to.hash
    }
  }
}

//5.异步滚动:0.5s后滚动到顶部
scrollBehavior (to, from, savedPosition) {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      resolve({ x: 0, y: 0 })
    }, 500)
  })
}
</code></pre>
<h3 id="十七-路由懒加载webpack的代码分割和vue的异步组件">十七、路由懒加载(webpack的代码分割和Vue的异步组件)</h3>
<pre><code class="language-js">//路由懒加载:当webpack打包的时候,会将代码打包成一个app.js,如果项目非常大,app.js的体积会非常大,利用webpack的代码分割功能将不同路由对应的组件分割成一个个js代码块,当点击相应的路由,才加载相应的js块
//写法有3种，这里推荐最合适的写法。

//导入一级路由组件
const Home = () =&gt; import(&quot;@/views/Home.vue&quot;);
const Classify = () =&gt; import(&quot;@/views/Classify.vue&quot;);
const Cart = () =&gt; import(&quot;@/views/Cart.vue&quot;);
const Me = () =&gt; import(&quot;@/views/Me.vue&quot;);
const NotFound = () =&gt; import(&quot;@/views/NotFound.vue&quot;);

const routes = [
  { path: &quot;/&quot;,redirect: &quot;/home&quot; },
  { path: &quot;/home&quot;,component: Home },
  { path: &quot;/classify&quot;,omponent: Classify },
  { path: &quot;/cart&quot;, component: Cart },
  { path: &quot;/me&quot;, component: Me },
  { path: &quot;*&quot;,component: NotFound }
];

//或者在配置时直接导入
const routes = [
  {
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;
  },
  {
    path: &quot;/home&quot;,
    name: &quot;Home&quot;,
    component: () =&gt; import(&quot;@/views/Home.vue&quot;)
  },
  {
    path: &quot;/classify&quot;,
    component: () =&gt; import(&quot;@/views/Classify.vue&quot;)
  },
  {
    path: &quot;/cart&quot;,
    component: () =&gt; import(&quot;@/views/Cart.vue&quot;)
  },
  {
    path: &quot;/me&quot;,
    component: () =&gt; import(&quot;@/views/Me.vue&quot;)
  },
  {
    path: &quot;*&quot;,
    component: () =&gt; import(&quot;@/views/NotFound.vue&quot;)
  }
];
</code></pre>
<h3 id="十八-keep-alive-缓存组件httpscnvuejsorgv2apikeep-alive">十八、keep-alive 缓存组件(https://cn.vuejs.org/v2/api/#keep-alive)</h3>
<pre><code class="language-js">//keep-alive本质是Vue的一个内置组件,使被包含的组件保留状态，或避免重新渲染 
//1.缓存普通组件
&lt;keep-alive&gt;
  &lt;my-button&gt;&lt;/my-button&gt;
&lt;keep-alive&gt;
//2.缓存动态组件,比如Home,About、User组件,其中需要Home,User组件缓存(二次切换路由不会触发生命周期钩子函数,F5刷新除外)。
&lt;keep-alive exclude=&quot;About&quot;&gt;
   &lt;router-view&gt;&lt;/router-view&gt;
&lt;keep-alive&gt;
//等价于
&lt;keep-alive include=&quot;Home,User&quot;&gt;
   &lt;router-view&gt;&lt;/router-view&gt;
&lt;keep-alive&gt;

//3.使用正则,数组，必须加冒号:
&lt;keep-alive :include=&quot;['Home', 'User']&quot;&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;

//4.路由映射表中配置keepAlive,筛选需要被缓存的组件
const routes = [
  {
    path: &quot;/&quot;,
    redirect: &quot;/home&quot;
  },
  {
    path: &quot;/home&quot;,
    meta: {
      keepAlive: true
    },
    component: () =&gt; import(&quot;@/views/Home.vue&quot;)
  },
  {
    path: &quot;/about&quot;,
    meta: {
      keepAlive: false
    },
    component: () =&gt; import(&quot;@/views/About.vue&quot;)
  },
  {
    path: &quot;/user&quot;,
    meta: {
      keepAlive: true
    },
    component: () =&gt; import(&quot;@/views/User.vue&quot;)
  }
];

//组件
&lt;keep-alive&gt;
    &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;


/*
Notes:
    1、keep-alive先匹配组件自身name选项,没有,在匹配components注册的键值
    2、keep-alive 不会在函数式组件中正常工作，因为它们没有缓存实例。
    3、exclude的优先级大于include.
    4、被keepAlive缓存的组件,不会触发生命周期钩子函数，如果想做一些事,可以使用activated(进入缓存组件时触发)钩子函数,而deactivated有点特殊，
    比如home(缓存)组件切换到about(未缓存),home的deactivated钩子会在about的created之后,mounted之前触发。
 */


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS中This指向最终释义]]></title>
        <id>https://codermakers.github.io/post/js-zhong-this-de-zui-zhong-zhi-xiang-chan-shu/</id>
        <link href="https://codermakers.github.io/post/js-zhong-this-de-zui-zhong-zhi-xiang-chan-shu/">
        </link>
        <updated>2020-04-07T14:32:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-this的指向分类">一、This的指向分类</h3>
<pre><code class="language-js">-1、全局环境下
    无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象window。
-2、函数环境下
    在函数内部，this的值取决于函数被调用的方式。this-&gt;执行环境（execution context)对象(非严格模式下,strict模式下,没有EC概念)
</code></pre>
<h3 id="二-细说各种情况下的this指向问题">二、细说各种情况下的This指向问题</h3>
<ul>
<li>2.1 对象打点调用自身方法,this指向该对象</li>
</ul>
<pre><code class="language-js">var people = {
  sayHi() {
    conose.log(this); //this --&gt;people
  }
};
people.sayHi();
</code></pre>
<p>-2.2 DOM绑定事件函数中的this，this指向该DOM对象,本质是隶属于2.1</p>
<pre><code class="language-js">  document.getElementById(&quot;btn&quot;).onclick = function(e){
     console.log(this)   //this--&gt;document.getElementById(&quot;btn&quot;)
  }
  //理解：本身DOM对象下的onclick方法调用
</code></pre>
<p>-2.3 定时器中的callback中的this，this指向window</p>
<pre><code class="language-js">window.setInterval(function() {
    console.log(this);
}, 1000);
window.setTimeout(function() {
    console.log(this);
}, 1000);

//换种写法
function callback(){
   console.log(this);
}
window.setInterval(callback, 1000);
window.setTimeout(callback, 1000);
//理解：setInterval还是setTimeout都是window下的方法，其中的callback也指向window
</code></pre>
<p>-2.4 数组迭代方法中的callback中的this,this指向window</p>
<pre><code class="language-js">//迭代方法
   - forEach(callback)
   - map(callback)
   - filter(callback)
   - every(callback)
   - some(callback)
// 以map为例，callback(迭代器)可以函数名放在全局环境，所以是window；

function evenFn(v,i){
   console.log(this) // this-&gt;window
   return v*2
}
[1,2,3,4].map(evenFn);

//或者
[1,2,3,4].map(v=&gt;v*2)
</code></pre>
<p>-2.5 使用 new 操作符实例化的对象, 构造函数中的this, 原型上方法中的 this,默认指向该实例</p>
<pre><code class="language-js">function Cat(name, age) {
  this.name = name;
  this.age = age;
  this.play = function() {
    console.log(this);
  };
}
Cat.prototype.run = function() {
  console.log(this); //this--&gt;利用构造函数new出的实例对象
};

let Kimi = new Cat(&quot;Kimi&quot;, 3);
Kimi.play();
Kimi.run();
</code></pre>
<ul>
<li>2.6 箭头函数中的this,this指向父级环境对象</li>
</ul>
<pre><code class="language-js">var obj = {
  name:'Kimi',
  run:()=&gt;{
    console.log(this) //this --&gt;window
  }
}
obj.run()
//理解:箭头函数中没有this,会找父级环境中的this.
</code></pre>
<h3 id="三-javascript中如何修改this">三、JavaScript中如何修改this?</h3>
<pre><code class="language-js">function print(){
  console.log('name:' + this.name);
  console.log(arguments)
}
var obj = {
  name:'Jack',
  age:18
}
//调用call
print.call(obj,1,2,3)  // -&gt;逐个传参
//调用apply
print.apply(obj,[1,2,3]) //类数组或者数组传参

// bind绑定this,返回一个函数，必须加()执行
print.bind(obj,[1,2,3])()   //传参形式无限制
/* 
 * 1、 Js中使用bind,call,apply方法可以手动修改this指向,都采用后续传参的形式.
 * 2、区别：
      1、call的传参是单个传递的，而 apply后续传递的参数是(或类数组)数组形式，arguments都是逐个参数的形式,而 bind没有规定，可以传各种值，对象，数组，基本值.
      2、call和 apply函数的执行是直接执行的，而 bind函数会返回一个函数，然后我们想要()调用的时候才会执行。
*/
</code></pre>
<h3 id="四-项目中如何使用this">四、项目中如何使用this?</h3>
<ul>
<li>4.1 保存当前环境对象</li>
</ul>
<pre><code class="language-js">//常以that、_that、_self、context等变量保存this
oBtn.addEventListener(&quot;click&quot;, function() {
  let _self = this; //保存this
  setTimeout(function() {
    alert(_self.innerHTML);
  }, timeout);
});

</code></pre>
<ul>
<li>4.2 作为返回值返回</li>
</ul>
<pre><code class="language-js">var tools = {
  fnA() {
    return this;
  },
  fnB() {
    return this;
  }
  // ...
};
tools.fnA().fnB(); //链式调用
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一张图看懂FLex布局]]></title>
        <id>https://codermakers.github.io/post/yi-zhang-tu-kan-dong-flex-bu-ju/</id>
        <link href="https://codermakers.github.io/post/yi-zhang-tu-kan-dong-flex-bu-ju/">
        </link>
        <updated>2020-04-07T12:18:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-flex-简明介绍">一、Flex 简明介绍</h3>
<blockquote>
<p>Flex布局是CSS3提出的一种新的布局方式,比起传统布局方式更加灵活，但在PC端有些属性只兼容到IE10,具体参考CanIUse的提供的数据，如果不兼容到老的IE浏览器,可考虑Flex布局。移动端建议直接考虑Flex布局。</p>
</blockquote>
<h3 id="二-flex布局图">二、Flex布局图</h3>
<figure data-type="image" tabindex="1"><img src="https://codermakers.github.io//post-images/1586316913467.png" alt="" loading="lazy"></figure>
<pre><code class="language-js"> 【注意点】:
    1、设置Flex布局后,子元素的float、clear和vertical-align属性将失效。
    2、flex-basis为子项目设置固定宽度,如200px，默认值auto
    3、flex-grow属性定义项目的放大比例，默认为0，负数无效。
    4、flex-shrink属性定义了项目的缩小比例,默认为1，负数无效。
    5、flex-flow：row nowrap(默认)
    6、align-self：定义单个子项目对齐方式。
    7、flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后2个选项可选。
    8、flex:1默认占满剩余空间。
</code></pre>
<h3 id="三-flex布局的应用场景">三、Flex布局的应用场景</h3>
<ul>
<li>4.1 垂直居中</li>
</ul>
<pre><code class="language-css">/*方式1*/
.flex { display: flex;  justify-content: center; align-items: center; }

/*方式2*/
.flex { display: flex；}
.item { margin: auto; }
</code></pre>
<ul>
<li>4.2 在移动端布局预先定义一些class类,使用时直接加。</li>
</ul>
<pre><code class="language-css">.box-flex{
  display: flex; 
}
.flex-1{
  flex:1
}
.box-align-center{
  display: flex;  justify-content: center; align-items: center; 
}
</code></pre>
<h3 id="五-flex布局实现骰子练习题实现如下图所示的骰子">五、Flex布局实现骰子练习题:实现如下图所示的骰子</h3>
<figure data-type="image" tabindex="2"><img src="https://codermakers.github.io//post-images/1586319853891.png" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;!-- 参考代码如下 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      .container {
        height: 600px;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .touzi {
        width: 110px;
        height: 110px;
        padding: 5px;
        margin: 10px;
        border: 1px solid #000;
        border-radius: 5px;
        background-color: #e7e7e7;
      }

      .dot {
        display: inline-block;
        width: 30px;
        height: 30px;
        background-color: #000;
        border-radius: 50%;
      }

      /* 1点 */
      .first-face {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      /* 2点 */
      .second-face {
        display: flex;
        justify-content: space-between;
      }
      .second-face .dot:nth-child(2) {
        align-self: flex-end;
      }

      /* 3点 */
      .third-face {
        display: flex;
        justify-content: space-between;
      }
      .third-face .dot:nth-child(2) {
        align-self: center;
      }
      .third-face .dot:nth-child(3) {
        align-self: flex-end;
      }

      /* 4点 */
      .fourth-face {
        display: flex;
        justify-content: space-between;
      }
      .fourth-face .column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      /* 5点 */
      .fifth-face {
        display: flex;
        justify-content: space-between;
      }
      .fifth-face .column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
      .fifth-face .column:nth-child(2) {
        justify-content: center;
      }

      /* 6点 */
      .sixth-face {
        display: flex;
        justify-content: space-between;
      }
      .sixth-face .column {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;!-- 1点 --&gt;
      &lt;div class=&quot;touzi first-face&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;!-- 2点 --&gt;
      &lt;div class=&quot;touzi second-face&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;!-- 3点 --&gt;
      &lt;div class=&quot;touzi third-face&quot;&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
      &lt;/div&gt;
      &lt;!-- 4点 --&gt;
      &lt;div class=&quot;touzi fourth-face&quot;&gt;
        &lt;div class=&quot;column&quot;&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;!-- 5点 --&gt;
      &lt;div class=&quot;touzi fifth-face&quot;&gt;
        &lt;div class=&quot;column&quot;&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;!-- 6点 --&gt;
      &lt;div class=&quot;touzi sixth-face&quot;&gt;
        &lt;div class=&quot;column&quot;&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;column&quot;&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
          &lt;span class=&quot;dot&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h3 id="五-参考链接">五、参考链接</h3>
<pre><code class="language-js">1、阮一峰Flex 布局教程  https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html
2、A Complete Guide to Flexbox：https://css-tricks.com/snippets/css/a-guide-to-flexbox/#flexbox-basics
3、Flex布局在线调试网站：https://the-echoplex.net/flexyboxes/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Gridea+Github Pages搭建个人静态博客]]></title>
        <id>https://codermakers.github.io/post/grideagithub-pagesconding/</id>
        <link href="https://codermakers.github.io/post/grideagithub-pagesconding/">
        </link>
        <updated>2020-03-25T13:21:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-github-pages-gridea的简明介绍">一、Github Pages、Gridea的简明介绍</h3>
<pre><code class="language-js">  Github Pages 是GitHub提供的一项功能，允许用户以个人或者组织站点创建创建一个静态网站，但Github Pages本身提供的主题很少且单一，而Gridea一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点，主题很好。同类型的Hexo等工具操作略显复杂。
</code></pre>
<h3 id="二-开始搭建个人博客之旅">二、开始搭建个人博客之旅</h3>
<ul>
<li>2.1 新建仓库<br>
<img src="https://codermakers.github.io//post-images/1586187298663.png" alt="" loading="lazy"></li>
</ul>
<pre><code class="language-js">注意点：
     1、新建的仓库名必须是username.github.io(个人)
     2、仓库必须是public,否则只能自己访问
</code></pre>
<ul>
<li>2.2 生成token令牌（用于Gridea和github远程仓库进行连接）<br>
<img src="https://codermakers.github.io//post-images/1586187857234.png" alt="" loading="lazy"></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://codermakers.github.io//post-images/1586187781974.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">注意点：
   1、点击个人头像setting，进入Developer settings,选择Personal access tokens,点击Generate token即可生成。
   2、复制个人token到本地，只会开启一次，注意保存。之后勾选个人repo权限即可
</code></pre>
<ul>
<li>2.3 下载Gridea客户端进行连接设置<br>
<img src="https://codermakers.github.io//post-images/1586188413134.png" alt="" loading="lazy"></li>
</ul>
<pre><code class="language-js">注意点：
     1、填写token令牌，点击“检测远程连接”,出现连接成功即可。
     2、填写完毕，一定要保存，切记。
</code></pre>
<h3 id="三-gridea配置个人博客主题">三、Gridea配置个人博客主题</h3>
<pre><code class="language-js">   Gridea的主题大多免费,除个别收费，就6块钱，看中哪个主题,直接点到主题的github主页，看安装
方法即可,一般是到release下下载最新的版本解压缩到Gridea站点源文件theme文件夹下。之后Gridea重启软件即可。
</code></pre>
<p><img src="https://codermakers.github.io//post-images/1586256910537.png" alt="" loading="lazy"><br>
<img src="https://codermakers.github.io//post-images/1586256941017.png" alt="" loading="lazy"></p>
<pre><code class="language-js">注意点：
     1、点击主题，选择更多主题，看到心意的主题下即可。
     2、有时候主题可能不生效，多重启几遍
</code></pre>
<h3 id="四-gridea撰写个人博客">四、Gridea撰写个人博客</h3>
<pre><code class="language-js">   撰写博客一定要注意：分类，支持makedown语法,写完之后，点击同步即可，Ctr+P随时预览效果，这里介绍一下&quot;列表中隐藏&quot;功能。勾选一下，如果此时文章没有编写完毕，即使保存，点击同步也不会被发布到远程。同时文章列表中的文章会被Hide字眼标识。写完之后，记得取消。
</code></pre>
<p><img src="https://codermakers.github.io//post-images/1586258346407.png" alt="" loading="lazy"><br>
<img src="https://codermakers.github.io//post-images/1586258354570.png" alt="" loading="lazy"></p>
<pre><code class="language-js">注意点：
     1、文章写完，一定要注意随时保存。
     2、点击预览,会在本地http://localhost:4000/archives/，点击同步，会在http://codermakers.github.io 看到自己发布的文章，如果没同步，多试几次。
</code></pre>
<h3 id="五-参考链接">五、参考链接</h3>
<pre><code class="language-js">1、GitHub Pages介绍 ：https://pages.github.com/
2、Gridea 官网详细配置：https://gridea.dev/gridea-start/
3、Suremotoo(B站用户)B站实操视频：：https://www.bilibili.com/video/BV1W4411H7zS
4、文章只记录主要步骤，次要配置看自己喜好配置。
</code></pre>
]]></content>
    </entry>
</feed>